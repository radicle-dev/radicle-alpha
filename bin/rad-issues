#!/usr/bin/env radicle

(load! "rad/prelude.rad")

(def base-name "http://machine.radicle.xyz/chains")

(def help
  (string-append
  "rad-issues - Radicle issue CLI

   Usage:
        rad [list|new] <chain-name>
        rad help

     list - Select from all issues to view or comment on
     new  - Create a new issue in $EDITOR
     help - Print this help and exit

   If <chain-name> begins with 'http://', that URL will be used. Otherwise,
  " base-name " will be prepended to <chain-name>." ))

(def make-chain-ref
  (fn [chain]
    (def name
      (if (eq? (take 7 chain) "http://")
          chain
          (string-append base-name chain)))
    (ref (chain/load-chain! name))))

(def list-issues
  (fn [chain]
    (def chain-ref (make-chain-ref chain))
    (load! "rad/prelude/io-utils.rad")
    (load! "rad/monadic/issues.rad")

    (def mk-key (fn [v]
      (def key (nth 0 v))
      (def val (nth 1 v))
      [(string-append (show key) " - " (lookup :title val)) val]))
    (def iss (dict-from-seq (map mk-key (seq (list-issues chain-ref)))))
    (def selected (fzf-select-by-key! iss))
    (def pretty-comment (fn [c]
      (string-append
        (lookup :github-username c) "[" (lookup :created-at c) "]: "
        (lookup :body c)
        "\n\n")))
    (def pretty-issue (fn [i]
      (string-append
         "Issue " (show (lookup :number i)) " : " (lookup :title i)
         "\nDescription: " (lookup :body i)
         "\nState: " (if (eq? (lookup :state i) :open) "open" "closed")
         "\nLabels: " (show (lookup :labels i))
         "\nComments:\n\n\n" (unlines (map pretty-comment (lookup :comments i)))
    )))
    (put-str! (pretty-issue selected))))

(def new-issue
  (fn [chain]
    (def chain-ref (make-chain-ref chain))
    (load! "rad/prelude/io-utils.rad")
    (load! "rad/monadic/issues.rad")
    (def template
";; Issue template. An empty or invalid value will abort.
{:title      \"Pick a title\"
 :body       \"Pick a body\"
 :labels     []
}
")
    (def iss (read (edit-in-editor! template)))
    (create-issue!
      chain-ref
      (insert
        :state :open
        (insert
           :comments []
           (insert
             :created-at (now!)
               iss))))))

(def args (get-args!))
(match args
  ["list" 'chain] (list-issues chain)
  ["new"  'chain] (new-issue chain)
  ["help"]        (put-str! help)
  _               (do
                    (put-str! (string-append "Unrecognized command" (show args)))
                    (put-str! help)))
