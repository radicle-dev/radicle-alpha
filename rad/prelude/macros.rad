(ns prelude.macros "Basic macros.")

(prelude.basic//req)
(require prelude.test-macro '[test])

(def expand-let
  (fn [bindings body]
    (cond
      (eq? bindings []) body
      (eq? (length bindings) 1) (throw 'macro-error "The bindings vector in a `let` must have an even number of forms.")
      :else (list
             (list
              (cons 'fn
                    (cons [(first bindings)]
                          (expand-let (rest (rest bindings))
                                      body)))
              (first (rest bindings)))))))

;; TODO(james): improve error messages.
(def let
  "A macro for defining local variables.

  Used as `(let [x1 e1 x2 e2 ... xn en] body..)` where the `xi` are symbols and
  the `ei` are expressions. Each pair `xi ei` establishes a binding of the
  symbol `xi` to the result of evaluating `ei`. The binding has effect on all
  the expressions that follow it, and the body (unless shadowed by another
  binding/def).

  Evaluation of the body takes place with the bindings in place, and its value
  becomes the value of the whole let-expression."
  (macro
   (fn args
     (first (expand-let (first args) (rest (vec-to-list args)))))))

(test "let"
      [ (let [] 42) ==> 42 ]
      [ (let [x (+ 42 1)] (+ x 1)) ==> 44 ]
      [ (let [x 42 y (+ x 1)] [x y]) ==> [42 43] ]
      [ (let [x 0] x x) ==> 0 ])

(test "multiple-macro-expansion"
      [ (let [x (if #t :a :b) y (if #f :f x)] (if 42 [x y] :boo)) ==> [:a :a]])
