;; List functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; nil

(def nil "The empty list." (list))

;; empty?

(def empty? (fn [ls] (or (eq? ls nil) (eq? ls []))))

(document 'empty?
  '(("seq" sequence))
  "True if 'seq' is empty, false otherwise.")

(:test "empty"
  [ (empty? (list 2)) ==> #f ]
  [ (empty? [2]) ==> #f ]
  [ (empty? []) ==> #t ]
)

;; reverse

(def reverse (fn [ls]
  (def go (Y2 (fn [go]
    (fn [acc new]
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(document 'reverse
  '(("list" list))
  "Returns the reversed 'list'.")


(:test "reverse"
  [ (reverse (list 1 2 3)) ==> (3 2 1) ]
)

;; range

(def range (Y2 (fn [range] (fn [from to]
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(document 'range
  '(("start" number) ("end" number))
  "Returns a list with all integers from 'start' to 'end', inclusive.")

(:test "range"
  [ (range 1 5) ==> (1 2 3 4 5) ]
)

;; concat

(def concat (fn [list1 list2]
  (foldr (fn [a b] (cons a b)) list2 list1)))

(document 'concat
  '(("list1" list) ("list2" list))
  "Concatenates 'list1' and 'list2'.")

(:test "concat"
  [ (concat '(1 2 3) '(4 5 6)) ==> (1 2 3 4 5 6) ]
)

;; filter

(def filter (Y2 (fn [filter] (fn [pred ls]
  (if (empty? ls)
      ls
  (if (pred (head ls))
      (cons (head ls) (filter pred (tail ls)))
      (filter pred (tail ls))))))))

(document 'filter
  '(("filter-cond" function) ("list" list))
  "Returns 'list' with only the elements that satisfy 'filter-cond'.")

(:test "filter"
  [ (filter (fn [x] (< x 10)) (list 3 10 11))
     ==> (3) ]
)

(def list-with-head
  "Given a value `x`, and two functions `f` and `g`, checks if `x` is a list with a
  head. If so applies `f` to the head, otherwise calls `g` with no args."
  (fn [x f g]
    (if (list? x)
      (if (> (length x) 0)
        (f (head x))
        (g))
      (g))))
