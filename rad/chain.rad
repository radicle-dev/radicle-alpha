;; Chains: Functions for dealing with chains.

;; A chain is conceptually:
;;   - A known starting state (i.e. environment, and the assumption that `eval
;;     == base-eval')
;;   - A sequence of inputs.

(def new-chain
  (fn [url]
    {:state (pure-env)
     :inputs (list)
     :url url
     :index 0}))

(document 'new-chain
          '(("url" string))
          "Return an empty chain dictionary with the given url.")


(def list-with-head
  (fn [x f g]
    (if (list? x)
      (if (> (length x) 0)
        (f (head x))
        (g))
      (g))))

;; eval-in-chain

(def eval-in-chain
  (fn [expr chain]
    (def x (eval expr (lookup :state chain)))
    (def result (nth 0 x))
    (def new-state (nth 1 x))
    (def new-chain
      (insert :state new-state
      (over (@ :input) (fn [input] (cons expr input))
      (over (@ :index) (fn [index] (+ 1 index))
      chain ))))
    {:chain new-chain
     :result result }))

(document 'eval-in-chain
          '(("expr" any) ("chain" chain))
          "Evaluates 'expr' in the 'chain' and returns a dict with the ':result' and the resulting ':chain'.")

((fn []
  (def empty-chain (new-chain ""))
  (def res (eval-in-chain '(+ 3 2) empty-chain))
  (def ~~> (fn [comp expected] (should-be "eval-in-chain" (view comp res) expected)))
  (~~> (@ :result) 5)
  (~~> (.. (@ :chain) (@ :input)) '((+ 3 2)))
  (~~> (.. (@ :chain) (@ :index)) 1)))

;; update-chain

(def update-chain
  (fn [chain]
    (def new-inputs
      (receive! (lookup :url chain) (lookup :index chain)))
    (def upd-ch
      (fn [ch expr]
        (def x (eval-in-chain expr ch))
        (view (@ :chain) x)))
    (foldl upd-ch chain new-inputs)))

(document 'update-chain
          '(("chain" chain))
          "Return a new chain updated with the new expressions from the remote chain")

(def load-chain
  (fn [url]
    (update-chain (new-chain url))))

(document 'load-chain
          '(("url" string))
          "Fetch the inputs of a remote chain and return a chain dictionary with the chain state.")

;; update-chain-ref

(def update-chain-ref
  (fn [chain-ref]
    (modify-ref chain-ref update-chain)))

(document 'update-chain-ref
          '(("chain" chain))
          "Update a ref containing a chain with the new expressions from the remote chain")

;; add-quit

(def add-quit
  (fn [after-quit-state before-quit-eval]
    (fn [expr env]
      (if (eq? expr :quit)
          (list :ok after-quit-state)
          (before-quit-eval expr env)))))

(document 'add-quit
          '(("after-quit-state" dict) ("before-quit-eval" fn))
          "Adds a ':quit' command to 'before-quit-eval', which switches to 'after-quit-state' (and to the eval in that state)")

;; store-exprs

(def store-exprs
 (fn [evalfn]
     (fn [expr env]
         (def env_ (over (.. (@ :env) (@ '_inputs)) (fn [x] (add-right expr x)) env))
         (evalfn expr env_ ))))

(document 'store-exprs
          '(("eval" fn))
          "Store each new evaluated expression in '_inputs'")

;; add-send
(def add-send
  (fn [oeval]
      (fn [expr env]
          (if (eq? expr :send)
              (do (def inpl (.. (@ :env) (@ '_inputs)))
                  (def chainl (.. (@ :env) (@ '_cur-chain)))
                  (map (fn [e] (send! (view chainl env) e)) (view inpl env))
                  (def env_ (set inpl [] env))
                  (list :ok env_))
              ((store-exprs oeval) expr env)))))

(document 'add-send
          '(("eval-fn" fn))
          "Add a :send special form that sends the contents of _input to the chain _cur-chain")

;; enter-remote-chain
(def enter-remote-chain
  "Make the eval behave as that of a remote chain."
  (fn [url]
    (def chain (load-chain url))
    (def chain-state (lookup :state chain))
    (def mod-state1
      (over (@ :env) (fn [x] (insert '_inputs [] x)) chain-state))
    (def mod-state2
      (over (@ :env)
            (fn [x] (insert '_cur-chain (lookup :url chain) x))
            mod-state1))
    (def mod-state3
      (over (.. (@ :env) (@ 'eval))
            (fn [x] (add-send (add-quit (get-current-env) x)))
            mod-state2))
    (list :ok mod-state3)))

(def eval__ "The eval in place when `chain.rad` is loaded." eval)

(def eval
  "An eval in which one can use `(:enter-chain url)` to make the
  eval behave as that of a remote chain, and `:send` to send all
  enqueued expressions."
  (fn [expr env]
      (if (list? expr)
          (cond
            (eq? (head expr) :enter-chain)
              (enter-remote-chain (head (eval__ (nth 1 expr) env)))
            :else (eval__ expr env))
          (eval__ expr env))))

(def eval-fn-app
  "Given a state, a function, an argument and a callback, returns
  the result of evaluating the function call on the arg in the given
  state, while also calling the callback on the result."
  (fn [state f arg cb]
    (def exec (base-eval (list f (list 'quote arg)) state))
    (cb (head exec))
    exec))

(def updatable-eval
  "Given an evaluation function `f`, returns a new one which augments `f` with a new
  command `(update expr)` which evaluates arbitrary expression using `base-eval`."
  (fn [sub-eval]
    (fn [expr state]
      (list-with-head
       expr
       (fn [cmd]
         (if (eq? cmd 'update)
           (base-eval (nth 1 expr) state)
           (sub-eval expr state)))
       (fn [] (sub-eval expr state))))))
