(define document
  (lambda (name args description)
    (define old (read-ref _doc-ref))
    (write-ref
       _doc-ref
       (insert name (dict :args args :desc description) old))))

(document 'document
  '(("name" atom) '("args" list) '("description" desc))
  "Documents an atom. The documentation can then be retrieved with '(doc name)'.")

;; doc

(define doc
  (lambda (name)
    (define the-doc (lookup name (read-ref _doc-ref)))
    (string-append
       (lookup :desc the-doc)
       "\nArguments:\n\t"
       (show (lookup :args the-doc)))))

(document 'doc
  '(("name" atom))
  "Retrieves the documentation for an atom, if there is any.")

;; should-be

(define should-be
  (lambda (name x y)
    (if (eq? x y)
        (print! (string-append "Test '" name "' succeeded"))
      (print! (string-append "Test '" name "' failed")))))

(document 'should-be
  '(("test-name" string) ("actual" any) ("expected" any))
  "Checks that 'actual' equals 'expected'. Used for tests")

(should-be "doc" (string? (doc 'doc)) #t)


;; boolean functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; not

(define not (lambda (x) (if x #f #t)))

(document 'not
  '(("arg" any))
  "True if 'arg' is #f, false otherwise.")

;; and

(define and
  (lambda (x y)
    (if x y x)))

(document 'and
  '(("arg1" any) ("arg2" any))
  "Returns 'arg2' if 'arg1' is not #f, otherwise returns 'arg1'")

(should-be "and" (and #t #t) #t)
(should-be "and" (and #t #f) #f)
(should-be "and" (and #f #t) #f)
(should-be "and" (and #f #f) #f)

;; or

(define or
  (lambda (x y)
    (if x x y)))

(document 'or
  '(("arg1" any) ("arg2" any))
  "Returns 'arg1' if 'arg1' is not #f, otherwise returns 'arg2'")

(should-be "or" (or #t #t) #t)
(should-be "or" (or #t #f) #t)
(should-be "or" (or #f #t) #t)
(should-be "or" (or #f #f) #f)

;; all

(define all
  (lambda (xs) (foldr and #t xs)))

(should-be "all" (all '()) #t)
(should-be "all" (all '(#t)) #t)
(should-be "all" (all '(#f)) #f)
(should-be "all" (all '(#t #t #t #t)) #t)
(should-be "all" (all '(#t #t #f #t)) #f)

;; some

(define some
  (lambda (xs) (foldr or #f xs)))

(should-be "some" (some '()) #f)
(should-be "some" (some '(#t)) #t)
(should-be "some" (some '(#f)) #f)
(should-be "some" (some '(#f #f #f)) #f)
(should-be "some" (some '(#t #t #t #t)) #t)
(should-be "some" (some '(#t #t #f #t)) #t)

;; y-combinators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define Y
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg) ((g g) arg)))))))
(define Y2
  (lambda (h)
    ((lambda (x) (x x))
     (lambda (g)
       (h (lambda (arg1 arg2) ((g g) arg1 arg2)))))))

((lambda ()
  (define fac (Y (lambda (f) (lambda (x) (if (< x 2) 1 (* x (f (- x 1))))))))
  (should-be "fac" (fac 10) 3628800)))

;; List functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; nil

(define nil (list))

;; empty?

(define empty? (lambda (ls) (eq? ls nil)))

(document 'empty?
  '(("list" list))
  "True if 'list' is empty, false otherwise.")

(should-be "empty" (empty? (list 2)) #f)


;; length

(define length
  (lambda (xs)
    (foldr (lambda (x acc) (+ acc 1)) 0 xs)))

(document 'length
  '(("list" list))
  "Returns the length of 'list'.")

(should-be "length" (length nil) 0)
(should-be "length" (length (list 2)) 1)

;; reverse

(define reverse (lambda (ls)
  (define go (Y2 (lambda (go)
    (lambda (acc new)
      (if (empty? new)
          acc
          (go (cons (head new) acc) (tail new)))))))
  (go (list) ls)))

(document 'reverse
  '(("list" list))
  "Returns the reversed 'list'.")

(should-be "reverse" (reverse (list 1 2 3)) (list 3 2 1))

;; range

(define range (Y2 (lambda (range) (lambda (from to)
  (if (eq? from to)
      (list to)
      (cons from (range (+ 1 from) to)))))))

(document 'range
  '(("start" number) ("end" number))
  "Returns a list with all integers from 'start' to 'end', inclusive.")

(should-be "range" (range 1 5) (list 1 2 3 4 5))

;; concat

(define concat (lambda (list1 list2)
  (foldr (lambda (a b) (cons a b)) list2 list1)))

(document 'concat
  '(("list1" list) ("list2" list))
  "Concatenates 'list1' and 'list2'.")

(should-be "concat" (concat '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6))


;; filter

(define filter (Y2 (lambda (filter) (lambda (pred ls)
  (if (empty? ls)
      ls
  (if (pred (head ls))
      (cons (head ls) (filter pred (tail ls)))
      (filter pred (tail ls))))))))

(document 'filter
  '(("filter-cond" function) ("list" list))
  "Returns 'list' with only the elements that satisfy 'filter-cond'.")

(should-be "filter"
  (filter (lambda (x) (< x 10)) (list 3 10 11))
  (list 3))

;; dict functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; dict-from-list

(define dict-from-list
  (lambda (xs)
    (foldr (lambda (kv acc) (insert (head kv) (head (tail kv)) acc)) (dict) xs)))

(document 'dict-from-list
  '(("list" list))
  "Creates a dictionary from a list of key-value pairs.")

(should-be "dict-from-list"
           (dict-from-list (list (list :one 1) (list :two 2)))
           (dict :one 1 :two 2))

;; keys

(define keys
  (lambda (d)
    (map head (seq d))))

(document 'keys
  '(("dict" dict))
  "Returns the list of keys in a dictionary.")

;; Uncomment this test once map is fixed.
;; (should-be "keys"
;;            (keys (dict :one 1 :two 2))
;;            '(:one :two))


;; modify-map
(define modify-map (lambda (key fn mp)
  (insert key (fn (lookup key mp)) mp)))

(should-be "modify-map"
  (modify-map 'a (lambda (x) (+ x 1)) (dict 'a 5))
  (dict 'a 6))

;; ref functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; modify-ref
(define modify-ref
  (lambda (r fn)
    (write-ref r (fn (read-ref r)))))

(document 'modify-ref
  '(("ref" ref) ("fn" function))
  "Modify 'ref' by applying the provided function.")

;; Lenses ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; make-lens

(define make-lens
  (lambda (g s)
    (dict 'getter g 'setter s)))

(document 'make-lens
  '(("getter" function) ("setter" function))
  "Makes a lens out of a getter and a setter.")

;; view

(define view
  (lambda (lens target)
    ((lookup 'getter lens) target)))

(document 'view
  '(("lens" dict) ("target" any))
  "View a value through a lens.")

;; set

(define set
  (lambda (lens new-view target)
    ((lookup 'setter lens) new-view target)))

(document 'set
  '(("lens" dict) ("value" any) ("target" any))
  "Set a value though a lens.")

;; id-lens

(define id-lens
  (make-lens
   (lambda (target) target)
   (lambda (new-view target) new-view)))

(document 'id-lens
  '()
  "The identity lens.")

;; ..

(define ..
  (lambda (lens1 lens2)
    (make-lens
     (lambda (target) (view lens2 (view lens1 target)))
     (lambda (new-view target) (set lens1 (set lens2 new-view (view lens1 target)) target)))))

(document '..
  '(("lens1" dict) ("lens2" dict))
  "Compose two lenses.")

;; ...

(define ... (lambda (lenses) (foldr .. id-lens lenses)))

(document '...
  '(("lenses" list))
  "Compose multiple lenses.")

;; over
(define over
  (lambda (lens f target)
    (set lens (f (view lens target)) target)))

(document 'over
  '(("lens" dict) ("fn" function) ("target" any))
  "Modify a value through a lens.")

;; @

(define @
  (lambda (k)
    (make-lens (lambda (mp) (lookup k mp))
               (lambda (v mp) (insert k v mp)))))

(document '@
  '(("key" any))
  " Returns a lens targetting keys of dicts.")

(should-be "view lens"
           (view (@ :one) (dict :one 1 :two 2))
           1)

(should-be "set lens"
           (set (@ :two) 42 (dict :one 1 :two 2))
           (dict :one 1 :two 42))

(should-be "over lens"
           (over (@ :one) (lambda (x) (+ x 1)) (dict :one 1 :two 2))
           (dict :one 2 :two 2))

(should-be "lens composition"
           (over (.. (@ :a) (@ :b))
                 (lambda (x) (+ x 1))
                 (dict :a (dict :b 2)))
           (dict :a (dict :b 3)))

(do (define d
      (lambda (x) (dict :a (dict :b (dict :c x)))))
    (should-be "deep lenses"
               (over (... (list (@ :a) (@ :b) (@ :c)))
                     (lambda (x) (+ x 1))
                     (d 0))
               (d 1)))

;; Lens access to refs

;; view-ref
(define view-ref
  (lambda (r lens)
    (view lens (read-ref r))))

(document 'view-ref
  '(("ref" ref) ("lens" dict))
  "Like 'view', but for refs.")

(should-be "view-ref"
           (view-ref (ref (dict :key 1)) (@ :key))
           1)

;; set-ref

(define set-ref
  (lambda (r lens v)
    (modify-ref r (lambda (x) (set lens v x)))))

(document 'set-ref
  '(("ref" ref) ("lens" dict) ("new-value" any))
  "Like 'set', but for refs.")

(should-be "set-ref"
           (do (define r (ref (dict :a 1)))
               (set-ref r (@ :a) 2)
               (view-ref r (@ :a)))
           2)
;; set-ref

(define over-ref
  (lambda (r lens f)
    (modify-ref r (lambda (x) (over lens f x)))))

(document 'over-ref
  '(("ref" ref) ("lens" dict) ("fn" function))
  "Like 'over', but for refs.")

(should-be "over-ref"
           (do (define r (ref (dict :a 2)))
               (over-ref r (@ :a) (lambda (x) (* x 2)))
               (view-ref r (@ :a)))
           4)

;; paper examples

(define sas-password "very secret")
(define sas-store (ref (dict)))
(define sas-eval-ref (ref eval))

;; self-amending key-val store
(define sas-starting-eval
  (lambda (expr)
    (define command (head expr))
    (cond
     (eq? command 'get) (lookup (nth 1 expr) (read-ref sas-store))
     (eq? command 'set) (modify-ref sas-store (lambda (s) (insert (nth 1 expr) (nth 2 expr) s)))
     (and (eq? command 'update)
          (eq? (nth 1 expr)
               sas-password))
     (write-ref sas-eval-ref (eval (nth 2 expr)))
     :else (throw 'invalid-command "Valid commands are: 'get', 'set' and 'update'."))))

;; Handle an input in the morphing state-machine.
(define state-machine-input
  (lambda (state i)
    (define upd (lambda (s) ((view-ref state (@ :transition-fn)) s i)))
    (over-ref state (@ :machine-state) upd)
    (print! (string-append "ACCEPTED! new state: " (show (view-ref state (@ :machine-state)))))))

;; Trigger a new vote
(define state-machine-new-trans
  (lambda (state func)
    (if (eq? (view-ref state (@ :voting)) :nothing)
        (do (set-ref state (@ :voting) (dict :votes (dict)
                                             :proposed-function func))
          (print! (string-append "A new transition function has been proposed! Please either agree or disagree with: " (show func))))
      (throw 'invalid-input "Can't propose new transition function while vote is ongoing."))))

(define state-machine-agree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (... (list (@ :voting) (@ :votes) (@ userid))) #t)
            (if (eq? (length (seq (view-ref state (.. (@ :voting) (@ :votes))))) (length voters))
                (do (set-ref state (@ :transition-fn) (eval (view-ref state (.. (@ :voting) (@ :proposed-function)))))
                    (set-ref state (@ :voting) :nothing)
                    (print! "Voting has finished; a new transition function is in effect."))
                '()))
        (throw 'invalid-input "Not allowed to vote."))))

(define state-machine-disagree
  (lambda (state voters userid)
    (if (member? userid voters)
        (do (set-ref state (@ :voting) :nothing)
            (print! "Voting has ended; someone disagreed."))
        (throw 'invalid-input "You are not allowed to vote."))))

;; Returns an eval which operates a state machine whose transition function may
;; be updated. To update the transition function all voters must agree on it.
(define state-machine-eval
  (lambda (voters init-state init-transition)
    (define state (ref (dict :machine-state init-state
                             :transition-fn init-transition
                             :voting :nothing)))
    (lambda (expr)
      (define verb (nth 0 expr))
      (define input (nth 1 expr))
      (cond
       (eq? verb 'input)          (state-machine-input     state input)
       (eq? verb 'new-trans-func) (state-machine-new-trans state input)
       (eq? verb 'agree)          (state-machine-agree     state voters input)
       (eq? verb 'disagree)       (state-machine-disagree  state voters input)))))

(define integer-machine
  (state-machine-eval (list "alice777" "bob_1337") 0 +))

(define discussion
  (state-machine-eval (list "james" "julian")
                      ""
                      (lambda (cur inp)
                        (string-append cur "\n\n" (head inp) ": " (head (tail inp))))))

(lambda (cur inp) (string-append cur "\n" (head inp) ": " (head (tail inp))))

;; (do (define eval-ref (ref eval)) (define eval (lambda (e) ((read-ref eval-ref) e))))

(define boom (quote (define eval (state-machine-eval '("alice" "bob") 0 +))))

;; Account stuff. Should be moved elsewhere when we have an import mechanism

(define create-currency (lambda ()

  ;; The map of all accounts
  (define accounts (ref (dict)))

  ;; Create an account with 10 coins.
  (define new-account (lambda (name)
    (modify-ref accounts (lambda (acc)
      (insert name 10 acc)))))

  ;; Get an account's balance
  (define account-balance (lambda (name)
    (lookup name (read-ref accounts))))

  ;; Transfer money
  (define transfer (lambda (from to amount)
    (define acc (read-ref accounts))
    (write-ref accounts (if (> amount (lookup from acc))
            (print! "not enough balance")
            (modify-map
              to
              (lambda (x) (+ x amount))
              (modify-map from (lambda (x) (- x amount)) acc))))))

  (define dispatch (lambda (m)
    (if (eq? m 'new-account) new-account
    (if (eq? m 'account-balance) account-balance
    (if (eq? m 'transfer) transfer
        (print! "error: currency- unknown message"))))))
  dispatch))

(define currency (create-currency))


(define new-eval (lambda (expr)
  (if (eq? (head expr) 'new-account)
      ((currency 'new-account) (head (tail expr)))
  (if (eq? (head expr) 'account-balance)
      ((currency 'account-balance) (head (tail expr)))
  (if (eq? (head expr) 'transfer)
      ((currency 'transfer) (head (tail expr)) (head (tail (tail expr))) (head
          (tail
                      (tail (tail expr)))))
  (print! "transaction must be new-account, transfer, or account-balance"))))))

;; Chains

(define empty-state (dict
    :env (dict 'eval 'base-eval)
    :refs (list)))

(define empty-chain (dict
    :state empty-state
    :logs (list)))

(define chains (ref (dict "root" empty-chain)))

;; Updates chain and prints new results.

(define update-chain (lambda (chain-name)
  (define cur-chains (read-ref chains))
  (define this-chain (lookup chain-name cur-chains))
  (define new-logs
    (receive!
      chain-name
      (length (lookup :logs this-chain))))

  ;; Eval the chain. If it fails to eval we don't change the ref and thrown an
  ;; exception.
  (define eval-next (lambda (acc new-expr)
    (define eval-step (eval-with-env new-expr acc))
    (print! (head eval-step))
    (head (tail eval-step))))
  (define eval-result (foldl eval-next (lookup :state this-chain) new-logs))
  (define updated-chain
     (modify-map :logs (lambda (x) (concat x new-logs))
       (insert :state eval-result this-chain)))
  (write-ref chains (insert chain-name updated-chain cur-chains))))

;; eval-in-chain

(define eval-in-chain (lambda (expr chain)
  (head (eval-with-env expr (lookup :state (lookup chain (read-ref
                                                          chains)))))))

(define chain-logs (lambda (chain)
  (lookup :logs (lookup chain (read-ref chains)))))

;; enter-chain

;; (define eval-ref (ref eval))
;;
;; (define enter-chain (lambda (chain-name)
;;   (define old-eval (read-ref eval-ref))
;;   (define state (lookup :state (lookup chain-name (read-ref chains))))
;;   (define local-state (ref state))
;;   (print! state)
;;   (write-ref eval-ref (lambda (expr)
;;     (print! expr)
;;     (if (eq? expr :quit) (do
;;                            (print! "leaving chain"
;;                            (write-ref eval-ref old-eval)))
;;         (do
;;           (define ev-result (eval-with-env expr state))
;;           (write-ref state (head (tail ev-result)))
;;           (print! ev-result)
;;           (head ev-result)))))))

;; The Repl

(define _initial_prompt-text
  "Welcome to radicle. Type (help) for help.")

(define help (lambda ()
  "radicle is a LISP-like language intendended for programming chains, and
  interacting with those chains.

  Type (doc <name>) for further documentation of <name>."))


(define repl
  (dict
     'name "repl"
     ;; Parse errors are thrown here
     'getter (lambda () (catch 'parse-error (get-line!) print!))))

(catch 'any
    (subscribe-to! repl print!)
    (lambda (x) (print! x) (subscribe-to! repl print!)))

(define eval (lambda (x) ((read-ref eval-ref) x)))
